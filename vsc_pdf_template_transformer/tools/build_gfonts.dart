#!/usr/bin/env dart
/*
 * Copyright (C) 2017, David PHAM-VAN <dev.nfet.net@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Adapted from the dart_pdf repo: https://github.com/DavBfr/dart_pdf
// This was cloned into order to remove the printing package's dependency on Flutter.
// This now also allows us to generate font themes.

import 'dart:convert';
import 'dart:io';

String _capitalize(String s) {
  if (s.isEmpty) return s;
  return '${s[0].toUpperCase()}${s.substring(1)}';
}

class FamilyDesc {
  FamilyDesc({
    required this.family,
    required this.variants,
  });

  final String family;
  final List<VariantDesc> variants;
}

class VariantDesc {
  VariantDesc({
    required this.variantName,
    required this.uri,
  });

  final String variantName;
  final Uri uri;
}

List<FamilyDesc> parseFamilies(Map m) {
  final families = <FamilyDesc>[];
  for (final f in m['items']) {
    final String familyName = f['family'].replaceAll(' ', '');
    final variants = <VariantDesc>[];
    final family = FamilyDesc(family: familyName, variants: variants);
    families.add(family);

    for (final s in f['files'].entries) {
      String variantName = s.key;

      variantName = variantName.replaceAll('100', 'Thin ');
      variantName = variantName.replaceAll('200', 'ExtraLight ');
      variantName = variantName.replaceAll('300', 'Light ');
      variantName = variantName.replaceAll('400', 'Regular ');
      variantName = variantName.replaceAll('500', 'Medium ');
      variantName = variantName.replaceAll('600', 'SemiBold ');
      variantName = variantName.replaceAll('700', 'Bold ');
      variantName = variantName.replaceAll('800', 'ExtraBold ');
      variantName = variantName.replaceAll('900', 'Black ');
      variantName = variantName.split(' ').map((e) => _capitalize(e)).join('');

      var uri = Uri.parse(s.value);
      // if (uri.isScheme('http')) {
      //   uri = uri.replace(scheme: 'https');
      // }

      if (!uri.path.endsWith('.ttf')) {
        continue;
      }

      if (familyName == 'NotoColorEmoji' && variantName == 'Regular') {
        // The URI that Google supplies doesn't work for some reason.
        uri = Uri.parse(
            'http://rawcdn.githack.com/googlefonts/noto-emoji/9a5261d871451f9b5183c93483cbd68ed916b1e9/fonts/NotoColorEmoji.ttf');
      }

      variants.add(VariantDesc(variantName: variantName, uri: uri));
    }
  }

  families.add(FamilyDesc(family: 'CupertinoIcons', variants: [
    VariantDesc(
      variantName: 'Regular',
      uri: Uri.parse(
          'https://rawcdn.githack.com/flutter/packages/ae209b1a361f6f46682f71a7fbf94dbe112553c9/third_party/packages/cupertino_icons/assets/CupertinoIcons.ttf'),
    )
  ]));
  families.add(FamilyDesc(family: 'MaterialIcons', variants: [
    VariantDesc(
      variantName: 'Regular',
      uri: Uri.parse(
          'https://fonts.gstatic.com/s/materialicons/v98/flUhRq6tzZclQEJ-Vdg-IuiaDsNZ.ttf'),
    )
  ]));

  return families;
}

void main(List<String> args) async {
  if (args.isEmpty) {
    stderr.writeln('Usage: tools/build_gfonts.dart google-fonts-api-key');
    exit(1);
  }

  if (!Directory('lib/src/fonts/').existsSync()) {
    stderr.writeln(
        'lib/src/fonts/ not found. You must run this from the project directory: tools/build_gfonts.dart ...');
    exit(1);
  }

  final f = File('lib/src/fonts/fonts.json');
  final d = StringBuffer();

  if (f.existsSync()) {
    d.write(await f.readAsString());
  } else {
    final key = args[0];
    final http = HttpClient();
    print('Downloading...');
    final q = await http.getUrl(Uri.parse(
        'https://content-webfonts.googleapis.com/v1/webfonts?key=$key'));
    final r = await q.close();

    await for (final c in r.transform(utf8.decoder)) {
      d.write(c);
    }

    await f.writeAsString(d.toString());
  }

  print('Converting...');
  final Map m = json.decode(d.toString());

  final file = File('lib/src/fonts/gfonts.dart');
  final output = file.openWrite();

  output.writeln('// GENERATED by tools/build_gfonts.dart');
  output.writeln('');
  output.writeln('import \'package:pdf/widgets.dart\';');
  output.writeln('');
  output.writeln('import \'font.dart\';');
  output.writeln('');
  output.writeln('/// Google Fonts by variant name.');
  output.writeln('final googleFonts = <String, Future<Font> Function()>{');
  final families = parseFamilies(m);
  for (final f in families) {
    for (final v in f.variants) {
      final fontName = '${f.family}-${v.variantName}';

      output.writeln("  '$fontName': () => getFont(url: '${v.uri}'),");
    }
  }
  output.writeln('};');

  output.write(r'''

Future<ThemeData> defaultTheme() => _googleFontTheme();

Future<ThemeData> _googleFontTheme({
  String? baseName,
  String? boldName,
  String? italicName,
  String? boldItalicName,
  String? emojiName,
  String? iconsName,
}) async {
  Font? base;
  Font? bold;
  Font? italic;
  Font? boldItalic;
  Font? emoji;
  Font? icons;
  await Future.wait([
    googleFonts[baseName ?? 'OpenSans-Regular']!().then((f) => base = f),
    googleFonts[boldName ?? 'OpenSans-Bold']!().then((f) => bold = f),
    googleFonts[italicName ?? 'OpenSans-Italic']!().then((f) => italic = f),
    googleFonts[boldItalicName ?? 'OpenSans-BoldItalic']!()
        .then((f) => boldItalic = f),
    googleFonts[emojiName ?? 'NotoColorEmoji-Regular']!()
        .then((f) => emoji = f),
    googleFonts[iconsName ?? 'MaterialIcons-Regular']!().then((f) => icons = f),
  ]);
  return ThemeData.withFont(
    base: base,
    bold: bold,
    italic: italic,
    boldItalic: boldItalic,
    icons: icons,
    fontFallback: emoji != null && base != null ? [emoji!, base!] : [],
  );
}

''');

  output.writeln('/// Google fonts family themes by family name.');
  output.writeln(
      'final googleFontThemes = <String, Future<ThemeData> Function()>{');

  for (final f in families.where((f) => f.variants.isNotEmpty)) {
    final regularFont = f.variants
        .firstWhere((v) => v.variantName == 'Regular',
            orElse: () => f.variants[0])
        .variantName;
    final hasBold = f.variants.any((v) => v.variantName == 'Bold');
    final hasItalic = f.variants.any((v) => v.variantName == 'Italic');
    final hasBoldItalic = f.variants.any((v) => v.variantName == 'BoldItalic');

    output.writeln("""
          '${f.family}': () => _googleFontTheme(
              baseName: '${f.family}-$regularFont',
""");

    if (hasBold) {
      output.writeln("   boldName: '${f.family}-Bold',");
    }
    if (hasItalic) {
      output.writeln("   italicName: '${f.family}-Italic',");
    }
    if (hasBoldItalic) {
      output.writeln("   boldItalicName: '${f.family}-BoldItalic',");
    }
    output.writeln('),');
  }

  output.writeln('};');

  await output.close();

  await Process.run('dart', ['format', '--fix', file.absolute.path]);
  print('Done');
}
